{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst crystallize = require(\"../../crystallize\");\n\nconst basketService = require(\"../../basket-service\");\n\nconst {\n  getClient\n} = require(\"./utils\");\n\nconst toKlarnaOrderModel = require(\"./to-klarna-order-model\");\n\nmodule.exports = async function renderCheckout({\n  checkoutModel,\n  context\n}) {\n  const {\n    basketModel,\n    customer,\n    confirmationURL,\n    termsURL,\n    checkoutURL\n  } = checkoutModel;\n  const {\n    user,\n    serviceCallbackHost\n  } = context;\n  let {\n    crystallizeOrderId,\n    klarnaOrderId\n  } = basketModel;\n  const basket = await basketService.get({\n    basketModel,\n    user\n  });\n  /**\n   * Use a Crystallize order and the fulfilment pipelines to\n   * manage the lifecycle of the order\n   */\n\n  if (crystallizeOrderId) {\n    await crystallize.orders.updateOrder(crystallizeOrderId, _objectSpread(_objectSpread({}, basket), {}, {\n      customer\n    }));\n  } else {\n    const crystallizeOrder = await crystallize.orders.createOrder(_objectSpread(_objectSpread({}, basket), {}, {\n      customer\n    }));\n    crystallizeOrderId = crystallizeOrder.id;\n  } // Setup the confirmation URL\n\n\n  const confirmation = new URL(confirmationURL.replace(\"{crystallizeOrderId}\", crystallizeOrderId));\n  confirmation.searchParams.append(\"klarnaOrderId\", \"{checkout.order.id}\");\n\n  const validKlarnaOrderModel = _objectSpread(_objectSpread({}, toKlarnaOrderModel(basket)), {}, {\n    purchase_country: \"NO\",\n    purchase_currency: basket.total.currency || \"NOK\",\n    locale: \"no-nb\",\n    merchant_urls: {\n      terms: termsURL,\n      checkout: checkoutURL,\n      confirmation: confirmation.toString(),\n      push: `${serviceCallbackHost}/webhooks/payment-providers/klarna/push?crystallizeOrderId=${crystallizeOrderId}&klarnaOrderId={checkout.order.id}`\n    }\n  });\n\n  const klarnaClient = await getClient();\n  /**\n   * Hold the HTML snippet that will be used on the\n   * frontend to display the Klarna checkout\n   */\n\n  let html = \"\";\n  /**\n   * There is already a Klarna order id for this user\n   * session, let's use that and not create a new one\n   */\n\n  if (klarnaOrderId) {\n    const {\n      error,\n      response\n    } = await klarnaClient.checkoutV3.updateOrder(klarnaOrderId, validKlarnaOrderModel);\n\n    if (!error) {\n      html = response.html_snippet;\n      klarnaOrderId = response.order_id;\n    } else {\n      throw new Error(error);\n    }\n  } else {\n    const {\n      error,\n      response\n    } = await klarnaClient.checkoutV3.createOrder(validKlarnaOrderModel);\n\n    if (!error) {\n      html = response.html_snippet;\n      klarnaOrderId = response.order_id;\n    } else {\n      throw new Error(error);\n    }\n  }\n  /**\n   * The Crystallize order creating is asynchronous, so we have\n   * to wait for the order to be fully persisted\n   */\n\n\n  await crystallize.orders.waitForOrderToBePersistated({\n    id: crystallizeOrderId\n  }); // Tag the Crystallize order with the Klarna order id\n\n  await crystallize.orders.updateOrder(crystallizeOrderId, _objectSpread(_objectSpread({}, basket), {}, {\n    additionalInformation: JSON.stringify({\n      klarnaOrderId,\n      klarnaStatus: \"not-completed\"\n    })\n  }));\n  return {\n    html,\n    klarnaOrderId,\n    crystallizeOrderId\n  };\n};","map":{"version":3,"sources":["/Users/acandael/Sites/webshop-anniek/crystallize-app/src/services/payment-providers/klarna/render-checkout.js"],"names":["crystallize","require","basketService","getClient","toKlarnaOrderModel","module","exports","renderCheckout","checkoutModel","context","basketModel","customer","confirmationURL","termsURL","checkoutURL","user","serviceCallbackHost","crystallizeOrderId","klarnaOrderId","basket","get","orders","updateOrder","crystallizeOrder","createOrder","id","confirmation","URL","replace","searchParams","append","validKlarnaOrderModel","purchase_country","purchase_currency","total","currency","locale","merchant_urls","terms","checkout","toString","push","klarnaClient","html","error","response","checkoutV3","html_snippet","order_id","Error","waitForOrderToBePersistated","additionalInformation","JSON","stringify","klarnaStatus"],"mappings":"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","sourcesContent":["const crystallize = require(\"../../crystallize\");\nconst basketService = require(\"../../basket-service\");\n\nconst { getClient } = require(\"./utils\");\nconst toKlarnaOrderModel = require(\"./to-klarna-order-model\");\n\nmodule.exports = async function renderCheckout({ checkoutModel, context }) {\n  const {\n    basketModel,\n    customer,\n    confirmationURL,\n    termsURL,\n    checkoutURL,\n  } = checkoutModel;\n  const { user, serviceCallbackHost } = context;\n\n  let { crystallizeOrderId, klarnaOrderId } = basketModel;\n\n  const basket = await basketService.get({ basketModel, user });\n\n  /**\n   * Use a Crystallize order and the fulfilment pipelines to\n   * manage the lifecycle of the order\n   */\n  if (crystallizeOrderId) {\n    await crystallize.orders.updateOrder(crystallizeOrderId, {\n      ...basket,\n      customer,\n    });\n  } else {\n    const crystallizeOrder = await crystallize.orders.createOrder({\n      ...basket,\n      customer,\n    });\n    crystallizeOrderId = crystallizeOrder.id;\n  }\n\n  // Setup the confirmation URL\n  const confirmation = new URL(\n    confirmationURL.replace(\"{crystallizeOrderId}\", crystallizeOrderId)\n  );\n  confirmation.searchParams.append(\"klarnaOrderId\", \"{checkout.order.id}\");\n\n  const validKlarnaOrderModel = {\n    ...toKlarnaOrderModel(basket),\n    purchase_country: \"NO\",\n    purchase_currency: basket.total.currency || \"NOK\",\n    locale: \"no-nb\",\n    merchant_urls: {\n      terms: termsURL,\n      checkout: checkoutURL,\n      confirmation: confirmation.toString(),\n      push: `${serviceCallbackHost}/webhooks/payment-providers/klarna/push?crystallizeOrderId=${crystallizeOrderId}&klarnaOrderId={checkout.order.id}`,\n    },\n  };\n\n  const klarnaClient = await getClient();\n\n  /**\n   * Hold the HTML snippet that will be used on the\n   * frontend to display the Klarna checkout\n   */\n  let html = \"\";\n\n  /**\n   * There is already a Klarna order id for this user\n   * session, let's use that and not create a new one\n   */\n  if (klarnaOrderId) {\n    const { error, response } = await klarnaClient.checkoutV3.updateOrder(\n      klarnaOrderId,\n      validKlarnaOrderModel\n    );\n\n    if (!error) {\n      html = response.html_snippet;\n      klarnaOrderId = response.order_id;\n    } else {\n      throw new Error(error);\n    }\n  } else {\n    const { error, response } = await klarnaClient.checkoutV3.createOrder(\n      validKlarnaOrderModel\n    );\n\n    if (!error) {\n      html = response.html_snippet;\n      klarnaOrderId = response.order_id;\n    } else {\n      throw new Error(error);\n    }\n  }\n\n  /**\n   * The Crystallize order creating is asynchronous, so we have\n   * to wait for the order to be fully persisted\n   */\n  await crystallize.orders.waitForOrderToBePersistated({\n    id: crystallizeOrderId,\n  });\n\n  // Tag the Crystallize order with the Klarna order id\n  await crystallize.orders.updateOrder(crystallizeOrderId, {\n    ...basket,\n    additionalInformation: JSON.stringify({\n      klarnaOrderId,\n      klarnaStatus: \"not-completed\",\n    }),\n  });\n\n  return {\n    html,\n    klarnaOrderId,\n    crystallizeOrderId,\n  };\n};\n"]},"metadata":{},"sourceType":"script"}