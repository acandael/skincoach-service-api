{"ast":null,"code":"const jwt = require(\"jsonwebtoken\");\n\nconst invariant = require(\"invariant\");\n\nconst emailService = require(\"../email-service\");\n/**\n * Todo: link to good JWT intro\n */\n\n\nconst JWT_SECRET = process.env.JWT_SECRET; // The cookie name to use for JTW token\n\nconst USER_TOKEN_NAME = \"user-token\";\nmodule.exports = {\n  USER_TOKEN_NAME,\n\n  getLogoutLink({\n    context\n  }) {\n    const {\n      publicHost\n    } = context;\n    return `${publicHost}/api/user/logout`;\n  },\n\n  authenticate(token) {\n    invariant(JWT_SECRET, \"process.env.JWT_SECRET is not defined\");\n\n    if (!token) {\n      return null;\n    }\n    /**\n     * Here you would confirm the token provided by the cookie is a valid token\n     * for a user. The boilerplate has no datastore or service to persist users,\n     * so we will assume that the token is valid.\n     */\n\n\n    const decoded = jwt.verify(token, JWT_SECRET);\n\n    if (!decoded) {\n      return null;\n    }\n\n    return {\n      email: decoded.email\n    };\n  },\n\n  async sendMagicLink({\n    email,\n    redirectURLAfterLogin,\n    context\n  }) {\n    invariant(JWT_SECRET, \"process.env.JWT_SECRET is not defined\");\n    const {\n      publicHost\n    } = context;\n    /**\n     * This is the page responsible of receiving the magic\n     * link token, and then calling the validateMagicLinkToken\n     * function from userService.\n     */\n\n    const loginLink = new URL(`${publicHost}/api/user/login-magic-link`);\n    /**\n     * Add the JWT to the callback url\n     * When the link is visited, we can validate the token\n     * again in the validateMagicLinkToken method\n     */\n\n    loginLink.searchParams.append(\"token\", jwt.sign({\n      email,\n      redirectURLAfterLogin\n    }, JWT_SECRET, {\n      expiresIn: \"36000s\"\n    }));\n    const {\n      success\n    } = await emailService.sendUserMagicLink({\n      loginLink: loginLink.toString(),\n      email\n    });\n    return {\n      success\n    };\n  },\n\n  async sendGiftCard({\n    email,\n    aanbieder,\n    message,\n    amount\n  }) {\n    console.log(email);\n    const {\n      success\n    } = await emailService.sendGiftCard({\n      email,\n      aanbieder,\n      message,\n      amount\n    });\n    return {\n      success\n    };\n  },\n\n  validateMagicLinkToken(token) {\n    invariant(JWT_SECRET, \"process.env.JWT_SECRET is not defined\");\n    /**\n     * Here we would want to fetch an entry matching the provided token from our\n     * datastore. This boilerplate does not have a datastore connected to it yet\n     * so we will just assume the token is for a real user and sign a login token\n     * accordingly.\n     */\n\n    try {\n      const decoded = jwt.verify(token, JWT_SECRET);\n      const {\n        email,\n        redirectURLAfterLogin\n      } = decoded;\n      const signedLoginToken = jwt.sign({\n        email\n      }, JWT_SECRET, {\n        expiresIn: \"24h\"\n      });\n      return {\n        success: true,\n        signedLoginToken,\n        redirectURLAfterLogin\n      };\n    } catch (error) {\n      console.log(error);\n      return {\n        success: false,\n        error\n      };\n    }\n  }\n\n};","map":{"version":3,"sources":["/Users/acandael/Sites/crystallize-app/src/services/user-service/index.js"],"names":["jwt","require","invariant","emailService","JWT_SECRET","process","env","USER_TOKEN_NAME","module","exports","getLogoutLink","context","publicHost","authenticate","token","decoded","verify","email","sendMagicLink","redirectURLAfterLogin","loginLink","URL","searchParams","append","sign","expiresIn","success","sendUserMagicLink","toString","sendGiftCard","aanbieder","message","amount","console","log","validateMagicLinkToken","signedLoginToken","error"],"mappings":"AAAA,MAAMA,GAAG,GAAGC,OAAO,CAAC,cAAD,CAAnB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,WAAD,CAAzB;;AAEA,MAAME,YAAY,GAAGF,OAAO,CAAC,kBAAD,CAA5B;AAEA;AACA;AACA;;;AACA,MAAMG,UAAU,GAAGC,OAAO,CAACC,GAAR,CAAYF,UAA/B,C,CAEA;;AACA,MAAMG,eAAe,GAAG,YAAxB;AAEAC,MAAM,CAACC,OAAP,GAAiB;AACfF,EAAAA,eADe;;AAEfG,EAAAA,aAAa,CAAC;AAAEC,IAAAA;AAAF,GAAD,EAAc;AACzB,UAAM;AAAEC,MAAAA;AAAF,QAAiBD,OAAvB;AAEA,WAAQ,GAAEC,UAAW,kBAArB;AACD,GANc;;AAOfC,EAAAA,YAAY,CAACC,KAAD,EAAQ;AAClBZ,IAAAA,SAAS,CAACE,UAAD,EAAa,uCAAb,CAAT;;AAEA,QAAI,CAACU,KAAL,EAAY;AACV,aAAO,IAAP;AACD;AAED;AACJ;AACA;AACA;AACA;;;AACI,UAAMC,OAAO,GAAGf,GAAG,CAACgB,MAAJ,CAAWF,KAAX,EAAkBV,UAAlB,CAAhB;;AACA,QAAI,CAACW,OAAL,EAAc;AACZ,aAAO,IAAP;AACD;;AAED,WAAO;AACLE,MAAAA,KAAK,EAAEF,OAAO,CAACE;AADV,KAAP;AAGD,GA3Bc;;AA4Bf,QAAMC,aAAN,CAAoB;AAAED,IAAAA,KAAF;AAASE,IAAAA,qBAAT;AAAgCR,IAAAA;AAAhC,GAApB,EAA+D;AAC7DT,IAAAA,SAAS,CAACE,UAAD,EAAa,uCAAb,CAAT;AAEA,UAAM;AAAEQ,MAAAA;AAAF,QAAiBD,OAAvB;AAEA;AACJ;AACA;AACA;AACA;;AACI,UAAMS,SAAS,GAAG,IAAIC,GAAJ,CAAS,GAAET,UAAW,4BAAtB,CAAlB;AAEA;AACJ;AACA;AACA;AACA;;AACIQ,IAAAA,SAAS,CAACE,YAAV,CAAuBC,MAAvB,CACE,OADF,EAEEvB,GAAG,CAACwB,IAAJ,CAAS;AAAEP,MAAAA,KAAF;AAASE,MAAAA;AAAT,KAAT,EAA2Cf,UAA3C,EAAuD;AACrDqB,MAAAA,SAAS,EAAE;AAD0C,KAAvD,CAFF;AAOA,UAAM;AAAEC,MAAAA;AAAF,QAAc,MAAMvB,YAAY,CAACwB,iBAAb,CAA+B;AACvDP,MAAAA,SAAS,EAAEA,SAAS,CAACQ,QAAV,EAD4C;AAEvDX,MAAAA;AAFuD,KAA/B,CAA1B;AAKA,WAAO;AAAES,MAAAA;AAAF,KAAP;AACD,GA1Dc;;AA2Df,QAAMG,YAAN,CAAmB;AAAEZ,IAAAA,KAAF;AAASa,IAAAA,SAAT;AAAoBC,IAAAA,OAApB;AAA6BC,IAAAA;AAA7B,GAAnB,EAA0D;AACxDC,IAAAA,OAAO,CAACC,GAAR,CAAYjB,KAAZ;AACA,UAAM;AAAES,MAAAA;AAAF,QAAc,MAAMvB,YAAY,CAAC0B,YAAb,CAA0B;AAClDZ,MAAAA,KADkD;AAElDa,MAAAA,SAFkD;AAGlDC,MAAAA,OAHkD;AAIlDC,MAAAA;AAJkD,KAA1B,CAA1B;AAOA,WAAO;AAAEN,MAAAA;AAAF,KAAP;AACD,GArEc;;AAsEfS,EAAAA,sBAAsB,CAACrB,KAAD,EAAQ;AAC5BZ,IAAAA,SAAS,CAACE,UAAD,EAAa,uCAAb,CAAT;AAEA;AACJ;AACA;AACA;AACA;AACA;;AAEI,QAAI;AACF,YAAMW,OAAO,GAAGf,GAAG,CAACgB,MAAJ,CAAWF,KAAX,EAAkBV,UAAlB,CAAhB;AACA,YAAM;AAAEa,QAAAA,KAAF;AAASE,QAAAA;AAAT,UAAmCJ,OAAzC;AAEA,YAAMqB,gBAAgB,GAAGpC,GAAG,CAACwB,IAAJ,CAAS;AAAEP,QAAAA;AAAF,OAAT,EAAoBb,UAApB,EAAgC;AACvDqB,QAAAA,SAAS,EAAE;AAD4C,OAAhC,CAAzB;AAIA,aAAO;AACLC,QAAAA,OAAO,EAAE,IADJ;AAELU,QAAAA,gBAFK;AAGLjB,QAAAA;AAHK,OAAP;AAKD,KAbD,CAaE,OAAOkB,KAAP,EAAc;AACdJ,MAAAA,OAAO,CAACC,GAAR,CAAYG,KAAZ;AACA,aAAO;AACLX,QAAAA,OAAO,EAAE,KADJ;AAELW,QAAAA;AAFK,OAAP;AAID;AACF;;AApGc,CAAjB","sourcesContent":["const jwt = require(\"jsonwebtoken\");\nconst invariant = require(\"invariant\");\n\nconst emailService = require(\"../email-service\");\n\n/**\n * Todo: link to good JWT intro\n */\nconst JWT_SECRET = process.env.JWT_SECRET;\n\n// The cookie name to use for JTW token\nconst USER_TOKEN_NAME = \"user-token\";\n\nmodule.exports = {\n  USER_TOKEN_NAME,\n  getLogoutLink({ context }) {\n    const { publicHost } = context;\n\n    return `${publicHost}/api/user/logout`;\n  },\n  authenticate(token) {\n    invariant(JWT_SECRET, \"process.env.JWT_SECRET is not defined\");\n\n    if (!token) {\n      return null;\n    }\n\n    /**\n     * Here you would confirm the token provided by the cookie is a valid token\n     * for a user. The boilerplate has no datastore or service to persist users,\n     * so we will assume that the token is valid.\n     */\n    const decoded = jwt.verify(token, JWT_SECRET);\n    if (!decoded) {\n      return null;\n    }\n\n    return {\n      email: decoded.email,\n    };\n  },\n  async sendMagicLink({ email, redirectURLAfterLogin, context }) {\n    invariant(JWT_SECRET, \"process.env.JWT_SECRET is not defined\");\n\n    const { publicHost } = context;\n\n    /**\n     * This is the page responsible of receiving the magic\n     * link token, and then calling the validateMagicLinkToken\n     * function from userService.\n     */\n    const loginLink = new URL(`${publicHost}/api/user/login-magic-link`);\n\n    /**\n     * Add the JWT to the callback url\n     * When the link is visited, we can validate the token\n     * again in the validateMagicLinkToken method\n     */\n    loginLink.searchParams.append(\n      \"token\",\n      jwt.sign({ email, redirectURLAfterLogin }, JWT_SECRET, {\n        expiresIn: \"36000s\",\n      })\n    );\n\n    const { success } = await emailService.sendUserMagicLink({\n      loginLink: loginLink.toString(),\n      email,\n    });\n\n    return { success };\n  },\n  async sendGiftCard({ email, aanbieder, message, amount }) {\n    console.log(email)\n    const { success } = await emailService.sendGiftCard({\n      email,\n      aanbieder,\n      message,\n      amount\n    });\n\n    return { success };\n  },\n  validateMagicLinkToken(token) {\n    invariant(JWT_SECRET, \"process.env.JWT_SECRET is not defined\");\n\n    /**\n     * Here we would want to fetch an entry matching the provided token from our\n     * datastore. This boilerplate does not have a datastore connected to it yet\n     * so we will just assume the token is for a real user and sign a login token\n     * accordingly.\n     */\n\n    try {\n      const decoded = jwt.verify(token, JWT_SECRET);\n      const { email, redirectURLAfterLogin } = decoded;\n\n      const signedLoginToken = jwt.sign({ email }, JWT_SECRET, {\n        expiresIn: \"24h\",\n      });\n\n      return {\n        success: true,\n        signedLoginToken,\n        redirectURLAfterLogin,\n      };\n    } catch (error) {\n      console.log(error);\n      return {\n        success: false,\n        error,\n      };\n    }\n  },\n};\n"]},"metadata":{},"sourceType":"script"}