{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nconst {\n  callCatalogueApi\n} = require(\"../crystallize/utils\");\n\nconst voucherService = require(\"../voucher-service\");\n\nconst shippingService = require(\"../shipping-service\");\n\nmodule.exports = {\n  async get({\n    basketModel,\n    context\n  }) {\n    const {\n      locale,\n      voucherCode\n    } = basketModel,\n          basketFromClient = _objectWithoutProperties(basketModel, [\"locale\", \"voucherCode\"]);\n\n    const {\n      user\n    } = context;\n    console.log(basketModel);\n    /**\n     * Resolve all the voucher codes to valid vouchers for the user\n     */\n\n    let voucher;\n\n    if (voucherCode) {\n      voucher = await voucherService.get({\n        code: voucherCode,\n        user\n      });\n    }\n    /**\n     * Get all products from Crystallize from their paths\n     */\n\n\n    const productDataFromCrystallize = await getProducts({\n      paths: basketFromClient.cart.map(p => p.path),\n      language: locale.crystallizeCatalogueLanguage\n    });\n    let vatType;\n    /**\n     * Compose the complete cart items enriched with\n     * data from Crystallize\n     */\n\n    const cart = basketFromClient.cart.map(itemFromClient => {\n      const product = productDataFromCrystallize.find(p => p.variants.some(v => v.sku === itemFromClient.sku));\n      /**\n       * Could not find this product for some reason. Happens if an\n       * old product path is given and it no longer exists\n       */\n\n      if (!product) {\n        return null;\n      }\n\n      vatType = product.vatType;\n      const variant = product.variants.find(v => v.sku === itemFromClient.sku);\n      const {\n        price,\n        currency\n      } = variant.priceVariants.find(pv => pv.identifier === itemFromClient.priceVariantIdentifier) || variant.priceVariants.find(p => p.identifier === \"default\");\n      const gross = price;\n      const net = price * 100 / (100 + vatType.percent);\n      return _objectSpread({\n        path: product.path,\n        quantity: itemFromClient.quantity || 1,\n        vatType,\n        price: {\n          gross,\n          net,\n          tax: vatType,\n          currency\n        }\n      }, variant);\n    }).filter(Boolean); // Calculate the totals\n\n    const total = cart.reduce((acc, curr) => {\n      const {\n        quantity,\n        price\n      } = curr;\n\n      if (price) {\n        acc.gross += price.gross * quantity;\n        acc.net += price.net * quantity;\n        acc.currency = price.currency;\n      }\n\n      return acc;\n    }, {\n      gross: 0,\n      net: 0,\n      tax: 0,\n      currency: \"N/A\"\n    });\n    total.tax = vatType;\n    let shipping = true;\n\n    if (shipping) {\n      total.gross += 8;\n    }\n\n    return {\n      voucher,\n      cart,\n      total\n    };\n  }\n\n};\n/**\n * Gets information for products with a given path.\n * Gets all of the products with a single request\n * by composing the query dynamically\n */\n\nasync function getProducts({\n  paths,\n  language\n}) {\n  if (paths.length === 0) {\n    return [];\n  }\n\n  const response = await callCatalogueApi({\n    query: `{\n      ${paths.map((path, index) => `\n        product${index}: catalogue(path: \"${path}\", language: \"${language}\") {\n          path\n          ... on Product {\n            vatType {\n              name\n              percent\n            }\n            variants {\n              id\n              sku\n              name\n              stock\n              priceVariants {\n                price\n                identifier\n                currency\n              }\n              attributes {\n                attribute\n                value\n              }\n              images {\n                url\n                variants {\n                  url\n                  width\n                  height\n                }\n              }\n            }\n          }\n        }\n      `)}\n    }`\n  });\n  return paths.map((_, i) => response.data[`product${i}`]).filter(p => !!p);\n}","map":{"version":3,"sources":["/Users/acandael/Sites/crystallize-app/src/services/basket-service/index.js"],"names":["callCatalogueApi","require","voucherService","shippingService","module","exports","get","basketModel","context","locale","voucherCode","basketFromClient","user","console","log","voucher","code","productDataFromCrystallize","getProducts","paths","cart","map","p","path","language","crystallizeCatalogueLanguage","vatType","itemFromClient","product","find","variants","some","v","sku","variant","price","currency","priceVariants","pv","identifier","priceVariantIdentifier","gross","net","percent","quantity","tax","filter","Boolean","total","reduce","acc","curr","shipping","length","response","query","index","_","i","data"],"mappings":"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","sourcesContent":["const { callCatalogueApi } = require(\"../crystallize/utils\");\nconst voucherService = require(\"../voucher-service\");\nconst shippingService = require(\"../shipping-service\");\n\nmodule.exports = {\n  async get({ basketModel, context }) {\n    const { locale, voucherCode, ...basketFromClient} = basketModel;\n    const { user } = context;\n\n    console.log(basketModel)\n    /**\n     * Resolve all the voucher codes to valid vouchers for the user\n     */\n    let voucher;\n    if (voucherCode) {\n      voucher = await voucherService.get({ code: voucherCode, user });\n    }\n\n    /**\n     * Get all products from Crystallize from their paths\n     */\n    const productDataFromCrystallize = await getProducts({\n      paths: basketFromClient.cart.map((p) => p.path),\n      language: locale.crystallizeCatalogueLanguage,\n    });\n\n    let vatType;\n\n    /**\n     * Compose the complete cart items enriched with\n     * data from Crystallize\n     */\n    const cart = basketFromClient.cart\n      .map((itemFromClient) => {\n        const product = productDataFromCrystallize.find((p) =>\n          p.variants.some((v) => v.sku === itemFromClient.sku)\n        );\n\n        /**\n         * Could not find this product for some reason. Happens if an\n         * old product path is given and it no longer exists\n         */\n        if (!product) {\n          return null;\n        }\n\n        vatType = product.vatType;\n\n        const variant = product.variants.find(\n          (v) => v.sku === itemFromClient.sku\n        );\n        const { price, currency } =\n          variant.priceVariants.find(\n            (pv) => pv.identifier === itemFromClient.priceVariantIdentifier\n          ) || variant.priceVariants.find((p) => p.identifier === \"default\");\n\n        const gross = price;\n\n        const net = (price * 100) / (100 + vatType.percent);\n\n        return {\n          path: product.path,\n          quantity: itemFromClient.quantity || 1,\n          vatType,\n          price: {\n            gross,\n            net,\n            tax: vatType,\n            currency,\n          },\n          ...variant,\n        };\n      })\n      .filter(Boolean);\n\n    // Calculate the totals\n    const total = cart.reduce(\n      (acc, curr) => {\n        const { quantity, price } = curr;\n        if (price) {\n          acc.gross += price.gross * quantity;\n          acc.net += price.net * quantity;\n          acc.currency = price.currency;\n        }\n\n        return acc;\n      },\n      { gross: 0, net: 0, tax: 0, currency: \"N/A\"}\n    );\n    total.tax = vatType;\n\n    \n\n    let shipping = true\n\n    if (shipping) {\n      total.gross += 8;\n    }\n\n    return {\n      voucher,\n      cart,\n      total,\n    };\n  },\n};\n\n/**\n * Gets information for products with a given path.\n * Gets all of the products with a single request\n * by composing the query dynamically\n */\nasync function getProducts({ paths, language }) {\n  if (paths.length === 0) {\n    return [];\n  }\n\n  const response = await callCatalogueApi({\n    query: `{\n      ${paths.map(\n        (path, index) => `\n        product${index}: catalogue(path: \"${path}\", language: \"${language}\") {\n          path\n          ... on Product {\n            vatType {\n              name\n              percent\n            }\n            variants {\n              id\n              sku\n              name\n              stock\n              priceVariants {\n                price\n                identifier\n                currency\n              }\n              attributes {\n                attribute\n                value\n              }\n              images {\n                url\n                variants {\n                  url\n                  width\n                  height\n                }\n              }\n            }\n          }\n        }\n      `\n      )}\n    }`,\n  });\n\n  return paths.map((_, i) => response.data[`product${i}`]).filter((p) => !!p);\n}\n"]},"metadata":{},"sourceType":"script"}